<!DOCTYPE html>
<html lang="ko">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style> 
        body { margin: 0; overflow: hidden; background: #1a1a1a; color: white; font-family: sans-serif; } 
        #info { position: absolute; top: 15px; left: 15px; pointer-events: none; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; border: 1px solid #444; }
        .stat-val { color: #52ff52; font-weight: bold; }
        .alert { color: #ff5252; font-weight: bold; animation: blink 0.5s infinite; }
        .berserk { color: #ff00ff; font-weight: bold; text-shadow: 0 0 5px #ff00ff; }
        .chaser-lvl { color: #ff9999; font-size: 0.9em; margin-top: 5px; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
    </style>
</head>
<body>
<div id="info">
    <h3 style="color:#ff5252; margin-top:0;">세대: <span id="gen">1</span></h3>
    <p>남은 도망자: <span id="alive" class="stat-val">0</span></p>
    <p>남은 술래: <span id="cCount" style="color:#ff5252; font-weight:bold;">4</span></p>
    <div id="chaserLevels" class="chaser-lvl"></div> <p id="statusRow">상태: <span id="cState">추격 중</span></p>
</div>
<script>
let chasers = [];
let runners = [];
let obstacles = [];
let barricades = [];
let foods = [];
let generation = 1;
let runnerCount = 25; 
let deadRunners = [];
let deathLocations = [];
let foodEatenCount = 0; // 부활용 카운트
let mudZone; // 세이프존

function setup() {
    createCanvas(windowWidth, windowHeight);
    // 세이프존 영역 설정
    mudZone = { x: width/2 - 150, y: height/2 - 150, w: 300, h: 300 };
    initObstacles();
    initGame();
}

function initObstacles() {
    obstacles = [];
    while (obstacles.length < 5) {
        let obs = { x: random(width*0.1, width*0.8), y: random(height*0.1, height*0.8), w: random(130, 200), h: random(130, 200) };
        // 세이프존 영역 피하기
        let buffer = 20;
        let overlap = !(obs.x + obs.w < mudZone.x - buffer || obs.x > mudZone.x + mudZone.w + buffer || 
                        obs.y + obs.h < mudZone.y - buffer || obs.y > mudZone.y + mudZone.h + buffer);
        if (!overlap) obstacles.push(obs);
    }
}

function initGame() {
    chasers = [];
    for(let i=0; i<4; i++) {
        chasers.push(new Chaser(random(width), random(height)));
    }
    barricades = [];
    foods = [];
    deathLocations = [];
    foodEatenCount = 0;
    for (let i = 0; i < 25; i++) spawnFood(true);
    
    if (deadRunners.length === 0) {
        for (let i = 0; i < runnerCount; i++) runners.push(new Runner(random(width), random(height)));
    } else {
        deadRunners.sort((a, b) => b.score - a.score);
        let newRunners = [];
        for(let i=0; i<5; i++) {
            if(deadRunners[i]) newRunners.push(new Runner(random(width), random(height), deadRunners[i].dna));
        }
        while(newRunners.length < runnerCount) {
            let parent = deadRunners[floor(random(deadRunners.length * 0.4))];
            newRunners.push(new Runner(random(width), random(height), mutate(parent.dna)));
        }
        runners = newRunners;
        deadRunners = [];
    }
}

function mutate(dna) {
    return {
        maxSpeed: constrain(dna.maxSpeed + random(-0.3, 0.3), 3, 6.5),
        viewDist: constrain(dna.viewDist + random(-30, 30), 180, 450),
        foodDist: constrain(dna.foodDist + random(-30, 30), 150, 500),
        barricadeProb: constrain(dna.barricadeProb + random(-0.02, 0.02), 0.01, 0.2)
    };
}

function spawnFood(isInitial = false) {
    let bestPos = null;
    let maxScore = -1;
    for (let i = 0; i < 20; i++) {
        let x = random(width);
        let y = random(height);
        let inWall = false;
        for (let obs of obstacles) {
            if (x > obs.x - 20 && x < obs.x + obs.w + 20 && y > obs.y - 20 && y < obs.y + obs.h + 20) { inWall = true; break; }
        }
        if (inWall) continue;
        let refPos = chasers.length > 0 ? chasers[0].pos : createVector(width/2, height/2);
        let score = isInitial ? 0 : p5.Vector.dist(createVector(x, y), refPos);
        if (score > maxScore) { maxScore = score; bestPos = createVector(x, y); }
    }
    if (bestPos) foods.push(bestPos);
}

function draw() {
    background(25);
    updateUI();
    if (frameCount % 60 === 0 && foods.length < 40) spawnFood();

    // 세이프존(진흙탕) 그리기
    fill(50, 40, 30, 150); rect(mudZone.x, mudZone.y, mudZone.w, mudZone.h, 30);
    fill(100, 80, 60, 100); textAlign(CENTER); textSize(12); text("MUD ZONE (SLOW)", mudZone.x + mudZone.w/2, mudZone.y + mudZone.h/2);

    let currentTime = millis();
    barricades = barricades.filter(bar => currentTime - bar.createdAt < 3000);

    if (chasers.length < 4 && frameCount % 180 === 0) {
        let spawned = new Chaser(random(width), random(height));
        spawned.level = 10; 
        chasers.push(spawned);
    }

    let allWalls = [...obstacles, ...barricades];

    fill(55); noStroke();
    for (let obs of obstacles) rect(obs.x, obs.y, obs.w, obs.h);
    fill(139, 69, 19); stroke(100, 50, 10);
    for (let bar of barricades) rect(bar.x, bar.y, bar.w, bar.h);
    fill(255, 215, 0); noStroke();
    for (let f of foods) ellipse(f.x, f.y, 7, 7);

    if (runners.length > 0 && chasers.length > 0) {
        for (let c of chasers) {
            c.isBerserk = (chasers.length === 1);
            let target = c.selectTarget(runners);
            let avoidWalls = c.isBerserk ? obstacles : allWalls;
            c.chase(target, avoidWalls);
            c.update(allWalls);
            c.display();
        }
    } else if (runners.length === 0) {
        generation++;
        initGame();
    }

    for (let i = runners.length - 1; i >= 0; i--) {
        let r = runners[i];
        r.flock(runners);
        r.searchFood(foods);
        
        let neighbors = 0;
        for(let other of runners) {
            if(p5.Vector.dist(r.pos, other.pos) < 120) neighbors++;
        }
        r.boostSpeed = map(neighbors, 1, 10, 0, 2.5);

        for(let c of chasers) {
            r.reactToChaser(c);
            r.hide(c, allWalls);
        }
        
        r.avoid(allWalls);
        r.update(allWalls);
        r.display();

        for (let j = chasers.length - 1; j >= 0; j--) {
            let c = chasers[j];
            let d = p5.Vector.dist(c.pos, r.pos);
            
            if (neighbors >= 3 && d < 80) { 
                chasers.splice(j, 1);
            } else if (d < 22) {
                deathLocations.push(r.pos.copy());
                c.level++; // 경험치 로직 유지
                c.fatigue = 0;
                r.score = frameCount;
                deadRunners.push(r);
                runners.splice(i, 1);
                break; 
            }
        }

        if (runners[i] && r.energy <= 0) {
            deadRunners.push(r);
            runners.splice(i, 1);
        }
    }
}

function updateUI() {
    document.getElementById('gen').innerText = generation;
    document.getElementById('alive').innerText = runners.length;
    document.getElementById('cCount').innerText = chasers.length;
    
    // 술래 레벨 UI 업데이트 추가
    let lvStr = chasers.map((c, i) => `술래${i+1}: Lv.${c.level}`).join(' | ');
    document.getElementById('chaserLevels').innerText = lvStr;

    let isStuck = chasers.some(c => c.stuckFrames > 30);
    let anyBerserk = chasers.some(c => c.isBerserk);
    
    let stateEl = document.getElementById('cState');
    if (anyBerserk) {
        stateEl.innerText = "광폭화 모드!!!";
        stateEl.className = "berserk";
    } else if (isStuck) {
        stateEl.innerText = "경로 재탐색 중!";
        stateEl.className = "alert";
    } else {
        stateEl.innerText = "추격 중";
        stateEl.className = "";
    }
}

function resolveCollision(agent, walls, isChaser = false) {
    for (let i = walls.length - 1; i >= 0; i--) {
        let w = walls[i];
        let cx = constrain(agent.pos.x, w.x, w.x + w.w);
        let cy = constrain(agent.pos.y, w.y, w.y + w.h);
        let d = dist(agent.pos.x, agent.pos.y, cx, cy);
        if (d < agent.radius) {
            if (isChaser && agent.isBerserk && walls[i].createdAt) {
                barricades.splice(barricades.indexOf(walls[i]), 1);
                continue; 
            }

            let overlap = agent.radius - d;
            let push = createVector(agent.pos.x - cx, agent.pos.y - cy);
            if (push.mag() === 0) push = p5.Vector.random2D();
            push.setMag(overlap);
            agent.pos.add(push);
            let normal = push.copy().normalize();
            let dot = agent.vel.dot(normal);
            if (dot < 0) {
                let vNormal = p5.Vector.mult(normal, dot);
                agent.vel.sub(vNormal);
            }
        }
    }
}

class Chaser {
    constructor(x, y) {
        this.pos = createVector(x, y);
        this.vel = createVector(0, 0);
        this.acc = createVector(0, 0);
        this.radius = 15;
        this.level = 1;
        this.maxSpeed = 4.3;
        this.stuckFrames = 0;
        this.fatigue = 0;
        this.isBerserk = false;
    }

    selectTarget(list) {
        let minD = Infinity; let target = list[0];
        for (let r of list) {
            let d = p5.Vector.dist(this.pos, r.pos);
            if (d < minD) { minD = d; target = r; }
        }
        return target;
    }

    chase(t, walls) {
        if(!t) return;
        this.fatigue += 0.001;
        let speedPenalty = min(this.fatigue, 1.5);
        
        let currentMaxSpeed = this.isBerserk ? 7.5 : max(2.5, this.maxSpeed + (this.level * 0.05) - speedPenalty);
        
        // 추가: 진흙탕 구역 진입 시 속도 대폭 감소
        if (this.pos.x > mudZone.x && this.pos.x < mudZone.x + mudZone.w && 
            this.pos.y > mudZone.y && this.pos.y < mudZone.y + mudZone.h) {
            currentMaxSpeed *= 0.25;
        }

        let desired = p5.Vector.sub(t.pos, this.pos).setMag(currentMaxSpeed);
        let sensorAngles = [0, QUARTER_PI, -QUARTER_PI];
        let blocked = false;
        let avoidForce = createVector(0, 0);
        for (let angle of sensorAngles) {
            let look = this.vel.copy().rotate(angle).setMag(60);
            let sensorPos = p5.Vector.add(this.pos, look);
            for (let w of walls) {
                if (sensorPos.x > w.x && sensorPos.x < w.x + w.w && sensorPos.y > w.y && sensorPos.y < w.y + w.h) {
                    blocked = true;
                    let escape = look.copy().rotate(angle === 0 ? HALF_PI : -angle).setMag(currentMaxSpeed);
                    avoidForce.add(escape);
                }
            }
        }
        if (this.vel.mag() < 0.8) this.stuckFrames++;
        else this.stuckFrames = 0;
        
        if (this.stuckFrames > 40) {
            let escape = createVector(-this.vel.y, this.vel.x).setMag(currentMaxSpeed * 2);
            this.acc.add(escape);
            if (this.stuckFrames > 60) this.stuckFrames = 0;
        } else if (blocked) {
            this.acc.add(p5.Vector.sub(avoidForce, this.vel).limit(1.0));
        } else {
            this.acc.add(p5.Vector.sub(desired, this.vel).limit(0.5));
        }
    }

    update(walls) {
        this.vel.add(this.acc);
        this.vel.limit(this.isBerserk ? 9 : 7);
        this.pos.add(this.vel);
        this.acc.mult(0);
        resolveCollision(this, walls, true);
    }

    display() {
        if (this.isBerserk) {
            fill(255, 0, 255); stroke(255); strokeWeight(3);
        } else {
            fill(255, 50, 50); stroke(255); strokeWeight(2);
        }
        ellipse(this.pos.x, this.pos.y, this.radius * 2, this.radius * 2);
        
        // 추가: 머리 위 레벨 표시
        fill(255); noStroke(); textAlign(CENTER); text("Lv." + this.level, this.pos.x, this.pos.y - 20);

        let fColor = this.isBerserk ? 255 : map(min(this.fatigue, 1.5), 0, 1.5, 255, 100);
        stroke(this.isBerserk ? color(255,0,255) : color(fColor, 50, 50));
        line(this.pos.x, this.pos.y, this.pos.x + this.vel.x*5, this.pos.y + this.vel.y*5);
    }
}

class Runner {
    constructor(x, y, dna) {
        this.pos = createVector(x, y);
        this.vel = p5.Vector.random2D();
        this.acc = createVector(0, 0);
        this.radius = 11;
        this.dna = dna ? dna : { maxSpeed: random(3.5, 5.5), viewDist: random(200, 350), foodDist: random(250, 450), barricadeProb: 0.05 };
        this.energy = 100;
        this.boredom = 0;
        this.score = 0;
        this.boostSpeed = 0;
        this.isDashing = false;
    }

    searchFood(foods) {
        if (this.energy > 90 && this.boredom < 100) return;
        let minD = Infinity; let bestF = null;
        for (let f of foods) {
            let d = p5.Vector.dist(this.pos, f);
            if (d < minD && d < this.dna.foodDist) { minD = d; bestF = f; }
        }
        if (bestF) {
            this.acc.add(p5.Vector.sub(bestF, this.pos).setMag(this.dna.maxSpeed).sub(this.vel).limit(0.3));
            if (minD < 15) { 
                foods.splice(foods.indexOf(bestF), 1); 
                this.energy = min(this.energy + 45, 150); 
                this.boredom = 0; 
                // 추가: 동료 부활 로직
                foodEatenCount++;
                if (foodEatenCount >= 12 && deadRunners.length > 0) {
                    let r = deadRunners.shift();
                    runners.push(new Runner(random(width), random(height), r.dna));
                    foodEatenCount = 0;
                }
            }
        }
    }

    reactToChaser(c) {
        let d = p5.Vector.dist(this.pos, c.pos);
        if (d < this.dna.viewDist) {
            let currentMax = this.dna.maxSpeed;
            if (d < 80 && this.energy > 10) {
                currentMax *= 1.8;
                this.energy -= 0.15;
                this.isDashing = true;
            } else {
                this.isDashing = false;
            }
            this.acc.add(p5.Vector.sub(this.pos, c.pos).setMag(currentMax).sub(this.vel).limit(0.6));
            
            // 추가: 진흙탕 내부에는 바리케이드 설치 금지
            let inMud = (this.pos.x > mudZone.x && this.pos.x < mudZone.x + mudZone.w && 
                         this.pos.y > mudZone.y && this.pos.y < mudZone.y + mudZone.h);
            if (!inMud && d < 110 && random(1) < this.dna.barricadeProb && this.energy > 30) {
                barricades.push({ x: this.pos.x - 20, y: this.pos.y - 20, w: 40, h: 40, createdAt: millis() });
                this.energy -= 25;
            }
        } else {
            this.isDashing = false;
        }
    }

    hide(c, walls) {
        if (this.boredom > 150) return;
        for (let w of walls) {
            let center = createVector(w.x + w.w/2, w.y + w.h/2);
            let hPos = p5.Vector.add(center, p5.Vector.sub(center, c.pos).setMag(w.w/2 + 50));
            if (p5.Vector.dist(this.pos, hPos) < 120) this.acc.add(p5.Vector.sub(hPos, this.pos).limit(0.4));
        }
    }

    avoid(walls) {
        let sensor = p5.Vector.add(this.pos, this.vel.copy().setMag(40));
        for (let w of walls) {
            if (sensor.x > w.x && sensor.x < w.x+w.w && sensor.y > w.y && sensor.y < w.y+w.h) {
                this.acc.add(createVector(-this.vel.y, this.vel.x).setMag(this.dna.maxSpeed).sub(this.vel).limit(0.6));
            }
        }
    }

    flock(others) {
        let sep = createVector(0,0); let count = 0;
        for (let o of others) {
            let d = p5.Vector.dist(this.pos, o.pos);
            if (d > 0 && d < 50) { sep.add(p5.Vector.sub(this.pos, o.pos).normalize().div(d)); count++; }
        }
        if (count > 0) this.acc.add(sep.setMag(this.dna.maxSpeed).limit(0.4));
    }

    update(walls) {
        this.energy -= 0.05;
        this.boredom = this.vel.mag() < 1.0 ? this.boredom + 1 : max(0, this.boredom - 0.5);
        this.vel.add(this.acc);
        let finalLimit = this.dna.maxSpeed + this.boostSpeed;
        if (this.isDashing) finalLimit *= 1.8;
        this.vel.limit(finalLimit);
        this.pos.add(this.vel);
        this.acc.mult(0);
        resolveCollision(this, walls);
        this.pos.x = (this.pos.x + width) % width;
        this.pos.y = (this.pos.y + height) % height;
    }

    display() {
        push(); translate(this.pos.x, this.pos.y); rotate(this.vel.heading());
        let rColor = this.isDashing ? color(255, 100, 0) : (this.boredom > 150 ? color(100, 200, 255) : color(80, 255, 80));
        fill(rColor); noStroke();
        triangle(-10, -7, -10, 7, 13, 0);
        fill(255, 215, 0); rect(-12, 12, map(this.energy, 0, 150, 0, 24), 3);
        pop();
    }
}
</script>
</body>
</html>